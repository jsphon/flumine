{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"fl\u016bmine Betfair trading framework with a focus on: simplicity modular pythonic rock-solid safe Support for market and custom streaming data (order, score and custom polling data in development) Join slack group Currently tested on Python 3.5, 3.6, 3.7 and 3.8. installation $ pip install flumine setup Get started... import betfairlightweight from flumine import Flumine trading = betfairlightweight . APIClient ( \"username\" ) framework = Flumine ( trading = trading , ) Example strategy: from flumine import BaseStrategy from betfairlightweight.filters import streaming_market_filter class ExampleStrategy ( BaseStrategy ): def start ( self ): # subscribe to streams print ( \"starting strategy 'ExampleStrategy'\" ) def check_market_book ( self , market_book ): # process_market_book only executed if this returns True if market_book . status != \"CLOSED\" : return True def process_market_book ( self , market_book ): # process marketBook object print ( market_book . status ) strategy = ExampleStrategy ( market_filter = streaming_market_filter ( event_type_ids = [ \"7\" ], country_codes = [ \"GB\" ], market_types = [ \"WIN\" ], ) ) flumine . add_strategy ( strategy ) Run framework: framework . run () Danger By default flumine will try and prevent coding errors which result in flash crashes and burnt fingers but use at your own risk as per the MIT license. Recommendation is not to remove the trading controls and carry out extensive testing before executing on live markets, even then only use new strategies on an account with a small balance (transfer balance to games wallet). Features Streaming Multiple strategies Order execution (in development) Paper trading (in development) Back testing (in development) Analytics (in development) Scores / RaceCard / InPlayService (in development) Dependencies flumine relies on these libraries: betfairlightweight - Betfair API support. tenacity - Used for connection retrying (streaming). python-json-logger - JSON logging. Installation Install with pip: $ pip install flumine flumine requires Python 3.5+","title":"Introduction"},{"location":"#installation","text":"$ pip install flumine","title":"installation"},{"location":"#setup","text":"Get started... import betfairlightweight from flumine import Flumine trading = betfairlightweight . APIClient ( \"username\" ) framework = Flumine ( trading = trading , ) Example strategy: from flumine import BaseStrategy from betfairlightweight.filters import streaming_market_filter class ExampleStrategy ( BaseStrategy ): def start ( self ): # subscribe to streams print ( \"starting strategy 'ExampleStrategy'\" ) def check_market_book ( self , market_book ): # process_market_book only executed if this returns True if market_book . status != \"CLOSED\" : return True def process_market_book ( self , market_book ): # process marketBook object print ( market_book . status ) strategy = ExampleStrategy ( market_filter = streaming_market_filter ( event_type_ids = [ \"7\" ], country_codes = [ \"GB\" ], market_types = [ \"WIN\" ], ) ) flumine . add_strategy ( strategy ) Run framework: framework . run () Danger By default flumine will try and prevent coding errors which result in flash crashes and burnt fingers but use at your own risk as per the MIT license. Recommendation is not to remove the trading controls and carry out extensive testing before executing on live markets, even then only use new strategies on an account with a small balance (transfer balance to games wallet).","title":"setup"},{"location":"#features","text":"Streaming Multiple strategies Order execution (in development) Paper trading (in development) Back testing (in development) Analytics (in development) Scores / RaceCard / InPlayService (in development)","title":"Features"},{"location":"#dependencies","text":"flumine relies on these libraries: betfairlightweight - Betfair API support. tenacity - Used for connection retrying (streaming). python-json-logger - JSON logging.","title":"Dependencies"},{"location":"#installation_1","text":"Install with pip: $ pip install flumine flumine requires Python 3.5+","title":"Installation"},{"location":"advanced/","text":"Advanced Trading Client betfairlightweight Streams Market Stream Data Stream Historical Stream Order Stream Custom Stream Trading Controls Logging Controls Background Workers By default flumine adds a keep_alive worker which runs every 1200s to make sure the client is either logged in or kept alive, further workers can be added: from flumine.worker import BackgroundWorker def func ( a ): print ( a ) worker = BackgroundWorker ( interval = 10 , function = func , args = ( \"hello\" ,) ) flumine . add_worker ( worker ) Error Handling Logging Custom Polling / Streaming Strategies Flumine The Flumine class can be adapted by overriding the following functions: _process_market_books called on MarketBook event _process_raw_data called on RawData event _process_end_flumine called on Flumine termination","title":"Advanced Usage"},{"location":"advanced/#advanced","text":"","title":"Advanced"},{"location":"advanced/#trading-client","text":"betfairlightweight","title":"Trading Client"},{"location":"advanced/#streams","text":"Market Stream Data Stream Historical Stream Order Stream Custom Stream","title":"Streams"},{"location":"advanced/#trading-controls","text":"","title":"Trading Controls"},{"location":"advanced/#logging-controls","text":"","title":"Logging Controls"},{"location":"advanced/#background-workers","text":"By default flumine adds a keep_alive worker which runs every 1200s to make sure the client is either logged in or kept alive, further workers can be added: from flumine.worker import BackgroundWorker def func ( a ): print ( a ) worker = BackgroundWorker ( interval = 10 , function = func , args = ( \"hello\" ,) ) flumine . add_worker ( worker )","title":"Background Workers"},{"location":"advanced/#error-handling","text":"","title":"Error Handling"},{"location":"advanced/#logging","text":"","title":"Logging"},{"location":"advanced/#custom-polling-streaming","text":"","title":"Custom Polling / Streaming"},{"location":"advanced/#strategies","text":"","title":"Strategies"},{"location":"advanced/#flumine","text":"The Flumine class can be adapted by overriding the following functions: _process_market_books called on MarketBook event _process_raw_data called on RawData event _process_end_flumine called on Flumine termination","title":"Flumine"},{"location":"design/","text":"Design Main loop Typical to most trading frameworks flumine uses an event driven design with the main thread handling these events through a FIFO queue . handles all events in order one by one runs in main Events: MARKET_CATALOGUE Betfair MarketCatalogue object MARKET_BOOK Betfair MarketBook object RAW_DATA Raw streaming data CURRENT_ORDERS Betfair CurrentOrders object CLEARED_MARKETS Betfair ClearedMarkets object CLEARED_ORDERS Betfair ClearedOrders object CLOSE_MARKET flumine Close Market update STRATEGY_RESET flumine Strategy Reset update CUSTOM_EVENT flumine Custom event update NEW_DAY flumine New Day update TERMINATOR flumine End instance update The above events are handled in the flumine class Streams Single stream (market) As above but 'data' (flumine listener) Future work: Separate threads Order stream Strategy Class based Subscribe to streams Single strategy subscribes to a single market stream Handles Stream reconnect Trading client login/logout Trading client keep alive Future work: Execution place/cancel/replace/update controls fillKill Market Catalogue Polling (scores/raceCard etc) CurrentOrders / ClearedOrders database connection/logging notes market middleware (analytics/logging) order middleware (controls) paper trading back testing","title":"Design"},{"location":"design/#design","text":"","title":"Design"},{"location":"design/#main-loop","text":"Typical to most trading frameworks flumine uses an event driven design with the main thread handling these events through a FIFO queue . handles all events in order one by one runs in main","title":"Main loop"},{"location":"design/#events","text":"MARKET_CATALOGUE Betfair MarketCatalogue object MARKET_BOOK Betfair MarketBook object RAW_DATA Raw streaming data CURRENT_ORDERS Betfair CurrentOrders object CLEARED_MARKETS Betfair ClearedMarkets object CLEARED_ORDERS Betfair ClearedOrders object CLOSE_MARKET flumine Close Market update STRATEGY_RESET flumine Strategy Reset update CUSTOM_EVENT flumine Custom event update NEW_DAY flumine New Day update TERMINATOR flumine End instance update The above events are handled in the flumine class","title":"Events:"},{"location":"design/#streams","text":"Single stream (market) As above but 'data' (flumine listener) Future work: Separate threads Order stream","title":"Streams"},{"location":"design/#strategy","text":"Class based Subscribe to streams Single strategy subscribes to a single market stream","title":"Strategy"},{"location":"design/#handles","text":"Stream reconnect Trading client login/logout Trading client keep alive Future work: Execution place/cancel/replace/update controls fillKill Market Catalogue Polling (scores/raceCard etc) CurrentOrders / ClearedOrders database connection/logging","title":"Handles"},{"location":"design/#notes","text":"market middleware (analytics/logging) order middleware (controls) paper trading back testing","title":"notes"},{"location":"help/","text":"Help Please try the following channels for any support: Betfair Developer Support Slack Group for any help in using the library API Status if things don't seem to be working","title":"Help"},{"location":"help/#help","text":"Please try the following channels for any support: Betfair Developer Support Slack Group for any help in using the library API Status if things don't seem to be working","title":"Help"},{"location":"quickstart/","text":"QuickStart Tip flumine uses betfairlightweight for communicating with the Betfair API, please see docs for how to use/setup before proceeding. First, start by importing flumine/bflw and creating a trading and framework client: from flumine import Flumine import betfairlightweight trading = betfairlightweight . APIClient ( \"username\" ) framework = Flumine ( trading = trading , ) Note flumine will handle login, logout and keep alive whilst the framework is running. A strategy can now be created by using the BaseStrategy class: from flumine import BaseStrategy class ExampleStrategy ( BaseStrategy ): def start ( self ): # subscribe to streams print ( \"starting strategy 'ExampleStrategy'\" ) def check_market_book ( self , market_book ): # process_market_book only executed if this returns True if market_book . status != \"CLOSED\" : return True def process_market_book ( self , market_book ): # process marketBook object print ( market_book . status ) This strategy can now be initiated with the market and data filter before being added to the framework: from betfairlightweight.filters import ( streaming_market_filter , streaming_market_data_filter , ) strategy = ExampleStrategy ( market_filter = streaming_market_filter ( event_type_ids = [ \"7\" ], country_codes = [ \"GB\" ], market_types = [ \"WIN\" ], ), market_data_filter = streaming_market_data_filter ( fields = [ \"EX_ALL_OFFERS\" ]) ) flumine . add_strategy ( strategy ) The framework can now be started: framework . run () Stream class By default the stream class will be a MarketStream which provides a MarketBook python object, if collecting data this can be changed to a DataStream class however process_raw_data will be called and not process_market_book: from flumine import BaseStrategy from flumine.streams.datastream import DataStream class ExampleDataStrategy ( BaseStrategy ): def process_raw_data ( self , publish_time , data ): print ( publish_time , data ) strategy = ExampleDataStrategy ( market_filter = streaming_market_filter ( event_type_ids = [ \"7\" ], country_codes = [ \"GB\" ], market_types = [ \"WIN\" ], ), stream_class = DataStream ) flumine . add_strategy ( strategy )","title":"QuickStart"},{"location":"quickstart/#quickstart","text":"Tip flumine uses betfairlightweight for communicating with the Betfair API, please see docs for how to use/setup before proceeding. First, start by importing flumine/bflw and creating a trading and framework client: from flumine import Flumine import betfairlightweight trading = betfairlightweight . APIClient ( \"username\" ) framework = Flumine ( trading = trading , ) Note flumine will handle login, logout and keep alive whilst the framework is running. A strategy can now be created by using the BaseStrategy class: from flumine import BaseStrategy class ExampleStrategy ( BaseStrategy ): def start ( self ): # subscribe to streams print ( \"starting strategy 'ExampleStrategy'\" ) def check_market_book ( self , market_book ): # process_market_book only executed if this returns True if market_book . status != \"CLOSED\" : return True def process_market_book ( self , market_book ): # process marketBook object print ( market_book . status ) This strategy can now be initiated with the market and data filter before being added to the framework: from betfairlightweight.filters import ( streaming_market_filter , streaming_market_data_filter , ) strategy = ExampleStrategy ( market_filter = streaming_market_filter ( event_type_ids = [ \"7\" ], country_codes = [ \"GB\" ], market_types = [ \"WIN\" ], ), market_data_filter = streaming_market_data_filter ( fields = [ \"EX_ALL_OFFERS\" ]) ) flumine . add_strategy ( strategy ) The framework can now be started: framework . run ()","title":"QuickStart"},{"location":"quickstart/#stream-class","text":"By default the stream class will be a MarketStream which provides a MarketBook python object, if collecting data this can be changed to a DataStream class however process_raw_data will be called and not process_market_book: from flumine import BaseStrategy from flumine.streams.datastream import DataStream class ExampleDataStrategy ( BaseStrategy ): def process_raw_data ( self , publish_time , data ): print ( publish_time , data ) strategy = ExampleDataStrategy ( market_filter = streaming_market_filter ( event_type_ids = [ \"7\" ], country_codes = [ \"GB\" ], market_types = [ \"WIN\" ], ), stream_class = DataStream ) flumine . add_strategy ( strategy )","title":"Stream class"}]}